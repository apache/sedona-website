<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Perform a spatial join operation on two Sedona spatial RDDs.</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body><div class="container">

<table width="100%" summary="page for sedona_spatial_join {apache.sedona}"><tr><td>sedona_spatial_join {apache.sedona}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Perform a spatial join operation on two Sedona spatial RDDs.</h2>

<h3>Description</h3>

<p>Given 'spatial_rdd' and 'query_window_rdd', return a pair RDD containing all
pairs of geometrical elements (p, q) such that p is an element of
'spatial_rdd', q is an element of 'query_window_rdd', and (p, q) satisfies
the spatial relation specified by 'join_type'.
</p>


<h3>Usage</h3>

<pre>
sedona_spatial_join(
  spatial_rdd,
  query_window_rdd,
  join_type = c("contain", "intersect"),
  partitioner = c("quadtree", "kdbtree"),
  index_type = c("quadtree", "rtree")
)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>spatial_rdd</code></td>
<td>
<p>Spatial RDD containing geometries to be queried.</p>
</td></tr>
<tr valign="top"><td><code>query_window_rdd</code></td>
<td>
<p>Spatial RDD containing the query window(s).</p>
</td></tr>
<tr valign="top"><td><code>join_type</code></td>
<td>
<p>Type of the join query (must be either &quot;contain&quot; or
&quot;intersect&quot;).
If 'join_type' is &quot;contain&quot;, then a geometry from 'spatial_rdd' will match
a geometry from the 'query_window_rdd' if and only if the former is fully
contained in the latter.
If 'join_type' is &quot;intersect&quot;, then a geometry from 'spatial_rdd' will
match a geometry from the 'query_window_rdd' if and only if the former
intersects the latter.</p>
</td></tr>
<tr valign="top"><td><code>partitioner</code></td>
<td>
<p>Spatial partitioning to apply to both 'spatial_rdd' and
'query_window_rdd' to facilitate the join query. Can be either a grid type
(currently &quot;quadtree&quot; and &quot;kdbtree&quot; are supported) or a custom spatial
partitioner object. If 'partitioner' is NULL, then assume the same spatial
partitioner has been applied to both 'spatial_rdd' and 'query_window_rdd'
already and skip the partitioning step.</p>
</td></tr>
<tr valign="top"><td><code>index_type</code></td>
<td>
<p>Controls how 'spatial_rdd' and 'query_window_rdd' will be
indexed (unless they are indexed already). If &quot;NONE&quot;, then no index will be
constructed and matching geometries will be identified in a doubly nested-
loop iterating through all possible pairs of elements from 'spatial_rdd'
and 'query_window_rdd', which will be inefficient for large data sets.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A spatial RDD containing the join result.
</p>


<h3>See Also</h3>

<p>Other Sedona spatial join operator: 
<code>sedona_spatial_join_count_by_key()</code>
</p>


<h3>Examples</h3>

<pre>
library(sparklyr)
library(apache.sedona)

sc &lt;- spark_connect(master = "spark://HOST:PORT")

if (!inherits(sc, "test_connection")) {
  input_location &lt;- "/dev/null" # replace it with the path to your input file
  rdd &lt;- sedona_read_dsv_to_typed_rdd(
    sc,
    location = input_location,
    delimiter = ",",
    type = "point",
    first_spatial_col_index = 1L
  )
  query_rdd_input_location &lt;- "/dev/null" # replace it with the path to your input file
  query_rdd &lt;- sedona_read_shapefile_to_typed_rdd(
    sc,
    location = query_rdd_input_location,
    type = "polygon"
  )
  join_result_rdd &lt;- sedona_spatial_join(
    rdd,
    query_rdd,
    join_type = "intersect",
    partitioner = "quadtree"
  )
}
</pre>

<hr /><div style="text-align: center;">[Package <em>apache.sedona</em> version 1.3.0 ]</div>
</div></body></html>
